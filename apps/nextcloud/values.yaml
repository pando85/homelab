nextcloud:
  image:
    repository: nextcloud
    tag: 27.1.1

  ingress:
    enabled: true
    className: nginx-external
    annotations:
      external-dns.alpha.kubernetes.io/enabled: "true"
      external-dns.alpha.kubernetes.io/target: grigri.cloud
      cert-manager.io/cluster-issuer: letsencrypt-prod-dns
      nginx.ingress.kubernetes.io/proxy-body-size: 10G
      nginx.ingress.kubernetes.io/server-snippet: |-
        server_tokens off;
        proxy_hide_header X-Powered-By;

        # Rule borrowed from `.htaccess` to handle Microsoft DAV clients
        location = / {
            if ( $http_user_agent ~ ^DavClnt ) {
                return 302 /remote.php/webdav/$is_args$args;
            }
        }

        location = /robots.txt {
            allow all;
            log_not_found off;
            access_log off;
        }

        # Make a regex exception for `/.well-known` so that clients can still
        # access it despite the existence of the regex rule
        # `location ~ /(\.|autotest|...)` which would otherwise handle requests
        # for `/.well-known`.
        location ^~ /.well-known {
            # The following 6 rules are borrowed from `.htaccess`

            location = /.well-known/carddav     { return 301 /remote.php/dav/; }
            location = /.well-known/caldav      { return 301 /remote.php/dav/; }
            # Anything else is dynamically handled by Nextcloud
            location ^~ /.well-known            { return 301 /index.php$uri; }

            try_files $uri $uri/ =404;
        }

        # Rules borrowed from `.htaccess` to hide certain paths from clients
        location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)(?:$|/)  { return 404; }
        location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console)              { return 404; }

      nginx.ingress.kubernetes.io/enable-global-auth: "false"
    tls:
      - hosts:
          - nextcloud.grigri.cloud
        secretName: nextcloud-tls-certificate

  redis:
    enabled: false

  internalDatabase:
    enabled: false
  externalDatabase:
    enabled: true
    type: postgresql
    database: nextcloud
    existingSecret:
      enabled: true
      secretName: nextcloud.nextcloud-postgres.credentials.postgresql.acid.zalan.do
      usernameKey: username
      passwordKey: password
    host: nextcloud-postgres
  cronjob:
    enabled: true
    failedJobsHistoryLimit: 1
    successfulJobsHistoryLimit: 1

  persistence:
    enabled: true
    existingClaim: nextcloud-nextcloud-data-zfs

    nextcloudData:
      enabled: false

  resources:
    limits:
      memory: 512Mi
    requests:
      cpu: 400m
      memory: 200Mi

  nextcloud:
    host: nextcloud.grigri.cloud
    existingSecret:
      enabled: true
      secretName: nextcloud
      usernameKey: username
      passwordKey: password
      smtpUsernameKey: smtp_username
      smtpPasswordKey: smtp_password
      smtpHostKey: smtp_host
    phpConfigs:
      uploadLimit.ini: |
        upload_max_filesize = 10G
        post_max_size = 10G
        max_input_time = 3600
        max_execution_time = 3600
        default_phone_region = ES
    defaultConfigs:
      .htaccess: true
      redis.config.php: true
    configs:
      proxy.config.php: |-
        <?php
        $CONFIG = array (
          'trusted_proxies' =>
          array(
              0 => '10.42.0.0/16',
          ),
          'forwarded_for_headers' =>
          array (
            0 => 'HTTP_X_FORWARDED_FOR',
          ),
        );
      # Circumvention for client freezes - https://github.com/nextcloud/desktop/issues/5094
      bulkupload.config.php: |-
        <?php
        $CONFIG = array (
          'bulkupload.enabled' => false,
        );
      encryption.config.php: |-
        <?php
        $CONFIG = array (
          'secret' =>  getenv('SECRET'),
          'passwordsalt' => getenv('PASSWORDSALT'),
        );

    extraEnv:
      - name: REDIS_HOST
        value: redis
      - name: REDIS_HOST_PORT
        value: "6379"
      - name: REDIS_HOST_PASSWORD
        valueFrom:
          secretKeyRef:
            name: nextcloud
            key: redis_password
      - name: SECRET
        valueFrom:
          secretKeyRef:
            name: nextcloud
            key: secret
      - name: PASSWORDSALT
        valueFrom:
          secretKeyRef:
            name: nextcloud
            key: passwordsalt
    mail:
      enabled: true
      fromAddress: grigriserver
      domain: gmail.com
      smtp:
        secure: tls
        port: 587
        authtype: LOGIN
    # LDAP TLS connection
    extraVolumes:
      - name: ca-bundle
        hostPath:
          path: /etc/ssl/certs/ca-certificates.crt
          type: File
    extraVolumeMounts:
      - name: ca-bundle
        mountPath: /etc/ssl/certs/ca-certificates.crt
        readOnly: true

  securityContext:
    fsGroupChangePolicy: "OnRootMismatch"

  nodeSelector:
    name: grigri

  livenessProbe:
    enabled: true
    periodSeconds: 30
  readinessProbe:
    enabled: true
    periodSeconds: 30
  startupProbe:
    enabled: true
    periodSeconds: 20

app-template:
  global:
    fullnameOverride: redis
  image:
    repository: redis
    tag: 7.2.1


  nodeSelector:
    name: grigri

  service:
    main:
      ports:
        http:
          enabled: false
        redis:
          enabled: true
          port: 6379

  command:
    - sh
  args:
    - -c
    - >-
      redis-server --requirepass $REDIS_PASSWORD
  resources:
    requests:
      cpu: 23m
      memory: 64M
    limits:
      cpu: 500m
      memory: 64M

  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - nextcloud
          topologyKey: kubernetes.io/hostname

  env:
    REDIS_PASSWORD:
      valueFrom:
        secretKeyRef:
          name: nextcloud
          key: redis_password
